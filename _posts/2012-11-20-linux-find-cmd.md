---
layout: post
title: "细数Linux中的那些可爱的查找命令"
description: "在最近的工作中，需要用到Linux环境来进行一些编译和调试。其中难免要用用到一些Linux常用的基本命令，本人是和很多人一样，多年来深受windows的毒害，对GUI的依赖相对较高，所以闲暇之余就来总结一下Linux中那些常用的查找命令，权当做是学习笔记吧。"
category: Linux_OS
tags: [useful东东,funny,LinuxOS]
---
{% include JB/setup %}

在最近的工作中，需要用到Linux环境来进行一些编译和调试。其中难免要用用到一些Linux常用的基本命令，本人是和很多人一样，多年来深受windows的毒害，对GUI的依赖相对较高，所以闲暇之余就来总结一下Linux中那些常用的查找命令，权当做是学习笔记吧。

首先来说说国外网站LinuxHaxor所总结了五条命令，我个人以为十分之受用，就拿来和大家分享一下。

###1. find

find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。

find的使用格式如下：

    $ find <指定目录> <指定条件> <指定动作>
    - <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。
    - <指定条件>： 所要搜索的文件的特征。
    - <指定动作>： 对搜索结果进行特定的处理。

如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。

find的使用实例：

    $ find . -name 'my*'

搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。

    $ find . -name 'my*' -ls

搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。

    $ find . -type f -mmin -10

搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。
###2. locate

locate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。

locate命令的使用实例：

　　$ locate /etc/sh

搜索etc目录下所有以sh开头的文件。

　　$ locate ~/m

搜索用户主目录下，所有以m开头的文件。

　　$ locate -i ~/m

搜索用户主目录下，所有以m开头的文件，并且忽略大小写。

###3. whereis

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。

whereis命令的使用实例：

　　$ whereis grep

###4. which

which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

which命令的使用实例：

　　$ which grep

###5. type

type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。

type命令的使用实例：

　　$ type cd

系统会提示，cd是shell的自带命令（build-in）。

　　$ type grep

系统会提示，grep是一个外部命令，并显示该命令的路径。

　　$ type -p grep

加上-p参数后，就相当于which命令。

***

***

掌握上面5个操作我想差不多在linux进行文件与程序的检索时可以得心应手了，不过这还不够，因为还有一个非常强有力的工具没有给大家介绍，没错，你猜对了，那就是：

###grep

grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

首先来说说她的工作方式，grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。grep也可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

下面来说说我们对grep命令的常用方法：

先上grep命令选项 

　　-? 

　　同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。 

　　-b，--byte-offset 

　　打印匹配行前面打印该行所在的块号码。 

　　-c,--count 

　　只打印匹配的行数，不显示匹配的内容。 

　　-f File，--file=File 

　　从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。 

　　-h，--no-filename 

　　当搜索多个文件时，不显示匹配文件名前缀。 

　　-i，--ignore-case 

　　忽略大小写差别。 

　　-q，--quiet 

　　取消显示，只返回退出状态。0则表示找到了匹配的行。 

　　-l，--files-with-matches 

　　打印匹配模板的文件清单。 

　　-L，--files-without-match 

　　打印不匹配模板的文件清单。 

　　-n，--line-number 

　　在匹配的行前面打印行号。 

　　-s，--silent 

　　不显示关于不存在或者无法读取文件的错误信息。 

　　-v，--revert-match 

　　反检索，只显示不匹配的行。 

　　-w，--word-regexp 

　　如果被\<和\>引用，就把表达式做为一个单词搜索。 

　　-V，--version 

　　显示软件版本信息。 

最后看几个grep命令的小例子，要用好grep这个工具，其实就是要写好正则表达式，所以这里不对grep的所有功能进行实例讲解，只列几个例子，讲解一个正则表达式的写法。 

　　$ ls -l | grep '^a' 

　　通过管道过滤ls -l输出的内容，只显示以a开头的行。 

　　$ grep 'test' d* 

　　显示所有以d开头的文件中包含test的行。 

　　$ grep 'test' aa bb cc 

　　显示在aa，bb，cc文件中匹配test的行。 

　　$ grep '[a-z]\{5\}' aa 

　　显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 

　　$ grep 'w\(es\)t.*\1' aa 

如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符，这些字符后面紧跟着另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用"\"号进行转义，直接写成'w(es)t.*\1'就可以了。
